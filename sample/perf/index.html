<!doctype html>
<script type='module'>
  import Replicache, { REPMWASMInvoker, REPMHTTPInvoker } from './node_modules/replicache/out/mod.js';

  const value = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';

  window.httpInvoker = new REPMHTTPInvoker('http://localhost:7002/');
  window.wasmInvoker = new REPMWASMInvoker();

  let counter = 0;
  async function makeRep(repmInvoker) {
    const name = 'bench' + (counter++);
    await Replicache.drop(name, { repmInvoke: repmInvoker.invoke });
    return new Replicache({
      batchURL: '',
      dataLayerAuth: '',
      diffServerAuth: '',
      diffServerURL: '',
      name,
      repmInvoker,
      syncInterval: null,
    });
  }

  async function populate(rep, { numKeys, parallel }) {
    var set = rep.register('populate', async (tx, args) => {
      var promises = [];
      for (var i = 0; i < numKeys; i++) {
        var p = tx.put(`key${i}`, value);
        if (parallel) {
          promises.push(p);
        } else {
          await p;
        }
      }
      if (promises.length) {
        await Promise.all(promises);
      }
    });
    await set({});
  }

  async function benchmark_populate(invoker, bench, opts) {
    var rep = await makeRep(invoker);
    const valSize = value.length;
    bench.reset();
    bench.setName(`populate ${valSize}x${opts.numKeys} (${opts.parallel ? 'parallel' : 'serial'})`);
    bench.setSize(opts.numKeys * valSize);
    await populate(rep, opts);
  }

  async function benchmark_scan(invoker, bench, opts) {
    var rep = await makeRep(invoker);
    const valSize = value.length;
    bench.setName(`scan ${valSize}x${opts.numKeys}`);
    bench.setSize(opts.numKeys * valSize);
    await populate(rep, opts);
    bench.reset();
    await rep.query(async (tx) => {
      var count = 0;
      for await (const value of tx.scan()) {
        // use the value to be confident we're not optimizing away.
        count += value.length;
      }
      console.log(count);
    });
  }

  async function benchmark(fn) {
    const n = 3;
    const times = [];
    let sum = 0;
    let name = String(fn);
    let size = null;
    for (var i = 0; i < n; i++) {
      let t0 = Date.now();
      await fn({
        reset: () => {
          t0 = Date.now();
        },
        setName: (n) => name = n,
        setSize: (s) => size = s,
      });
      const dur = Date.now() - t0;
      times.push(dur);
      sum += dur;
    }

    times.sort();
    const median = times[Math.floor(n / 2)];
    const out = [
      name,
      `Median: ${median}`,
    ];
    if (size) {
      out.push('Throughput: ' + humanSize(size / median * 1000) + '/s');
    }
    log(...out);
  }

  window.main = async function (invoker) {
    log(`Running benchmarks with ${invoker.constructor.name} please wait...`)
    await benchmark((bench) => benchmark_populate(invoker, bench, { numKeys: 1000, parallel: false }));
    await benchmark((bench) => benchmark_populate(invoker, bench, { numKeys: 1000, parallel: true }));
    await benchmark((bench) => benchmark_scan(invoker, bench, { numKeys: 5000 }));
    log('Done!');
  }

  function humanSize(bytes) {
    if (bytes == 0) { return '0.00 B'; }
    var e = Math.floor(Math.log(bytes) / Math.log(1024));
    return (bytes / Math.pow(1024, e)).toFixed(2) + ' ' + ' KMGTP'.charAt(e) + 'B';
  }

  function log() {
    document.querySelector('#output').value += Array.prototype.join.call(arguments, ' | ') + '\n';
  }
</script>

<p>
  <b>IMPORTANT:</b> Close web inspector to get accurate benchmark results.

<p>
  <button onclick='main(wasmInvoker)'>Run Rust Benchmarks</button>
  <button onclick='main(httpInvoker)'>Run Go Benchmarks</button>

<p>
  <textarea id='output' disabled style='display:block; width:100%; height: 400px;'></textarea>