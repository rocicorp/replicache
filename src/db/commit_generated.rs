#![allow(warnings)]

// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod commit {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(u8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum MetaTyped {
        NONE = 0,
        LocalMeta = 1,
        SnapshotMeta = 2,
    }

    pub const ENUM_MIN_META_TYPED: u8 = 0;
    pub const ENUM_MAX_META_TYPED: u8 = 2;

    impl<'a> flatbuffers::Follow<'a> for MetaTyped {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for MetaTyped {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = u8::to_le(self as u8);
            let p = &n as *const u8 as *const MetaTyped;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = u8::from_le(self as u8);
            let p = &n as *const u8 as *const MetaTyped;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for MetaTyped {
        type Output = MetaTyped;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<MetaTyped>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_META_TYPED: [MetaTyped; 3] = [
        MetaTyped::NONE,
        MetaTyped::LocalMeta,
        MetaTyped::SnapshotMeta,
    ];

    #[allow(non_camel_case_types)]
    pub const ENUM_NAMES_META_TYPED: [&'static str; 3] = ["NONE", "LocalMeta", "SnapshotMeta"];

    pub fn enum_name_meta_typed(e: MetaTyped) -> &'static str {
        let index = e as u8;
        ENUM_NAMES_META_TYPED[index as usize]
    }

    pub struct MetaTypedUnionTableOffset {}
    pub enum LocalMetaOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct LocalMeta<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for LocalMeta<'a> {
        type Inner = LocalMeta<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> LocalMeta<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            LocalMeta { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args LocalMetaArgs<'args>,
        ) -> flatbuffers::WIPOffset<LocalMeta<'bldr>> {
            let mut builder = LocalMetaBuilder::new(_fbb);
            builder.add_mutation_id(args.mutation_id);
            if let Some(x) = args.original_hash {
                builder.add_original_hash(x);
            }
            if let Some(x) = args.mutator_args_json {
                builder.add_mutator_args_json(x);
            }
            if let Some(x) = args.mutator_name {
                builder.add_mutator_name(x);
            }
            builder.finish()
        }

        pub const VT_MUTATOR_NAME: flatbuffers::VOffsetT = 4;
        pub const VT_MUTATOR_ARGS_JSON: flatbuffers::VOffsetT = 6;
        pub const VT_MUTATION_ID: flatbuffers::VOffsetT = 8;
        pub const VT_ORIGINAL_HASH: flatbuffers::VOffsetT = 10;

        #[inline]
        pub fn mutator_name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(LocalMeta::VT_MUTATOR_NAME, None)
        }
        #[inline]
        pub fn mutator_args_json(&self) -> Option<&'a [u8]> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    LocalMeta::VT_MUTATOR_ARGS_JSON,
                    None,
                )
                .map(|v| v.safe_slice())
        }
        #[inline]
        pub fn mutation_id(&self) -> u64 {
            self._tab
                .get::<u64>(LocalMeta::VT_MUTATION_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn original_hash(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(LocalMeta::VT_ORIGINAL_HASH, None)
        }
    }

    pub struct LocalMetaArgs<'a> {
        pub mutator_name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub mutator_args_json: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub mutation_id: u64,
        pub original_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for LocalMetaArgs<'a> {
        #[inline]
        fn default() -> Self {
            LocalMetaArgs {
                mutator_name: None,
                mutator_args_json: None,
                mutation_id: 0,
                original_hash: None,
            }
        }
    }
    pub struct LocalMetaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> LocalMetaBuilder<'a, 'b> {
        #[inline]
        pub fn add_mutator_name(&mut self, mutator_name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LocalMeta::VT_MUTATOR_NAME,
                mutator_name,
            );
        }
        #[inline]
        pub fn add_mutator_args_json(
            &mut self,
            mutator_args_json: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LocalMeta::VT_MUTATOR_ARGS_JSON,
                mutator_args_json,
            );
        }
        #[inline]
        pub fn add_mutation_id(&mut self, mutation_id: u64) {
            self.fbb_
                .push_slot::<u64>(LocalMeta::VT_MUTATION_ID, mutation_id, 0);
        }
        #[inline]
        pub fn add_original_hash(&mut self, original_hash: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                LocalMeta::VT_ORIGINAL_HASH,
                original_hash,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LocalMetaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            LocalMetaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<LocalMeta<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum SnapshotMetaOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct SnapshotMeta<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SnapshotMeta<'a> {
        type Inner = SnapshotMeta<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> SnapshotMeta<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SnapshotMeta { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args SnapshotMetaArgs<'args>,
        ) -> flatbuffers::WIPOffset<SnapshotMeta<'bldr>> {
            let mut builder = SnapshotMetaBuilder::new(_fbb);
            builder.add_last_mutation_id(args.last_mutation_id);
            if let Some(x) = args.server_state_id {
                builder.add_server_state_id(x);
            }
            builder.finish()
        }

        pub const VT_LAST_MUTATION_ID: flatbuffers::VOffsetT = 4;
        pub const VT_SERVER_STATE_ID: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn last_mutation_id(&self) -> u64 {
            self._tab
                .get::<u64>(SnapshotMeta::VT_LAST_MUTATION_ID, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn server_state_id(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SnapshotMeta::VT_SERVER_STATE_ID, None)
        }
    }

    pub struct SnapshotMetaArgs<'a> {
        pub last_mutation_id: u64,
        pub server_state_id: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for SnapshotMetaArgs<'a> {
        #[inline]
        fn default() -> Self {
            SnapshotMetaArgs {
                last_mutation_id: 0,
                server_state_id: None,
            }
        }
    }
    pub struct SnapshotMetaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> SnapshotMetaBuilder<'a, 'b> {
        #[inline]
        pub fn add_last_mutation_id(&mut self, last_mutation_id: u64) {
            self.fbb_
                .push_slot::<u64>(SnapshotMeta::VT_LAST_MUTATION_ID, last_mutation_id, 0);
        }
        #[inline]
        pub fn add_server_state_id(&mut self, server_state_id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SnapshotMeta::VT_SERVER_STATE_ID,
                server_state_id,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        ) -> SnapshotMetaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            SnapshotMetaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SnapshotMeta<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum MetaOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Meta<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Meta<'a> {
        type Inner = Meta<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Meta<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Meta { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args MetaArgs<'args>,
        ) -> flatbuffers::WIPOffset<Meta<'bldr>> {
            let mut builder = MetaBuilder::new(_fbb);
            if let Some(x) = args.typed {
                builder.add_typed(x);
            }
            if let Some(x) = args.checksum {
                builder.add_checksum(x);
            }
            if let Some(x) = args.basis_hash {
                builder.add_basis_hash(x);
            }
            if let Some(x) = args.local_create_date {
                builder.add_local_create_date(x);
            }
            builder.add_typed_type(args.typed_type);
            builder.finish()
        }

        pub const VT_LOCAL_CREATE_DATE: flatbuffers::VOffsetT = 4;
        pub const VT_BASIS_HASH: flatbuffers::VOffsetT = 6;
        pub const VT_CHECKSUM: flatbuffers::VOffsetT = 8;
        pub const VT_TYPED_TYPE: flatbuffers::VOffsetT = 10;
        pub const VT_TYPED: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn local_create_date(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Meta::VT_LOCAL_CREATE_DATE, None)
        }
        #[inline]
        pub fn basis_hash(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Meta::VT_BASIS_HASH, None)
        }
        #[inline]
        pub fn checksum(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Meta::VT_CHECKSUM, None)
        }
        #[inline]
        pub fn typed_type(&self) -> MetaTyped {
            self._tab
                .get::<MetaTyped>(Meta::VT_TYPED_TYPE, Some(MetaTyped::NONE))
                .unwrap()
        }
        #[inline]
        pub fn typed(&self) -> Option<flatbuffers::Table<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Meta::VT_TYPED, None)
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn typed_as_local_meta(&self) -> Option<LocalMeta<'a>> {
            if self.typed_type() == MetaTyped::LocalMeta {
                self.typed().map(|u| LocalMeta::init_from_table(u))
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn typed_as_snapshot_meta(&self) -> Option<SnapshotMeta<'a>> {
            if self.typed_type() == MetaTyped::SnapshotMeta {
                self.typed().map(|u| SnapshotMeta::init_from_table(u))
            } else {
                None
            }
        }
    }

    pub struct MetaArgs<'a> {
        pub local_create_date: Option<flatbuffers::WIPOffset<&'a str>>,
        pub basis_hash: Option<flatbuffers::WIPOffset<&'a str>>,
        pub checksum: Option<flatbuffers::WIPOffset<&'a str>>,
        pub typed_type: MetaTyped,
        pub typed: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for MetaArgs<'a> {
        #[inline]
        fn default() -> Self {
            MetaArgs {
                local_create_date: None,
                basis_hash: None,
                checksum: None,
                typed_type: MetaTyped::NONE,
                typed: None,
            }
        }
    }
    pub struct MetaBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> MetaBuilder<'a, 'b> {
        #[inline]
        pub fn add_local_create_date(
            &mut self,
            local_create_date: flatbuffers::WIPOffset<&'b str>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Meta::VT_LOCAL_CREATE_DATE,
                local_create_date,
            );
        }
        #[inline]
        pub fn add_basis_hash(&mut self, basis_hash: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Meta::VT_BASIS_HASH, basis_hash);
        }
        #[inline]
        pub fn add_checksum(&mut self, checksum: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Meta::VT_CHECKSUM, checksum);
        }
        #[inline]
        pub fn add_typed_type(&mut self, typed_type: MetaTyped) {
            self.fbb_
                .push_slot::<MetaTyped>(Meta::VT_TYPED_TYPE, typed_type, MetaTyped::NONE);
        }
        #[inline]
        pub fn add_typed(&mut self, typed: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Meta::VT_TYPED, typed);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetaBuilder<'a, 'b> {
            let start = _fbb.start_table();
            MetaBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Meta<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum CommitOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Commit<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Commit<'a> {
        type Inner = Commit<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Commit<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Commit { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args CommitArgs<'args>,
        ) -> flatbuffers::WIPOffset<Commit<'bldr>> {
            let mut builder = CommitBuilder::new(_fbb);
            if let Some(x) = args.value_hash {
                builder.add_value_hash(x);
            }
            if let Some(x) = args.meta {
                builder.add_meta(x);
            }
            builder.finish()
        }

        pub const VT_META: flatbuffers::VOffsetT = 4;
        pub const VT_VALUE_HASH: flatbuffers::VOffsetT = 6;

        #[inline]
        pub fn meta(&self) -> Option<Meta<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Meta<'a>>>(Commit::VT_META, None)
        }
        #[inline]
        pub fn value_hash(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Commit::VT_VALUE_HASH, None)
        }
    }

    pub struct CommitArgs<'a> {
        pub meta: Option<flatbuffers::WIPOffset<Meta<'a>>>,
        pub value_hash: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for CommitArgs<'a> {
        #[inline]
        fn default() -> Self {
            CommitArgs {
                meta: None,
                value_hash: None,
            }
        }
    }
    pub struct CommitBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> CommitBuilder<'a, 'b> {
        #[inline]
        pub fn add_meta(&mut self, meta: flatbuffers::WIPOffset<Meta<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Meta>>(Commit::VT_META, meta);
        }
        #[inline]
        pub fn add_value_hash(&mut self, value_hash: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Commit::VT_VALUE_HASH, value_hash);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CommitBuilder<'a, 'b> {
            let start = _fbb.start_table();
            CommitBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Commit<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    #[inline]
    pub fn get_root_as_commit<'a>(buf: &'a [u8]) -> Commit<'a> {
        flatbuffers::get_root::<Commit<'a>>(buf)
    }

    #[inline]
    pub fn get_size_prefixed_root_as_commit<'a>(buf: &'a [u8]) -> Commit<'a> {
        flatbuffers::get_size_prefixed_root::<Commit<'a>>(buf)
    }

    #[inline]
    pub fn finish_commit_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Commit<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_commit_buffer<'a, 'b>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        root: flatbuffers::WIPOffset<Commit<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod commit
